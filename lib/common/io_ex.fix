// Extensions for `Std::IO`.
module Minilib.Common.IOEx;

import Minilib.Monad.IO;

// Flushes a file stream.
// For details, see Linux manual page for [fflush()](https://man7.org/linux/man-pages/man3/fflush.3.html).
//
// NOTE: `Std::IO::flush` may be a better choice.
fflush : [m: MonadIOFail] IOHandle -> m ();
fflush = |handle| lift_iofail $ do {
    clear_errno.lift;;
    let file_ptr = *handle.get_file_ptr.lift;
    let res = *FFI_CALL_IO[I32 fflush(Ptr), file_ptr].lift;
    if res < 0_I32 {
        throw("fflush failed!: errno=" + (*get_errno.lift).to_string)
    };
    pure()
};

// Gets the value of an environment variable.
// If the specified variable is not found, this function returns an empty string.
//
// # Parameters
// - `name`: a variable name
getenv: [m: MonadIO] String -> m String;
getenv = |name| lift_io $ do {
    let p_value = *name.borrow_c_str_io(|p_name|
        FFI_CALL_IO[Ptr getenv(Ptr), p_name]
    );
    if p_value == nullptr {
        pure $ ""
    } else {
        String::unsafe_from_c_str_ptr_io(p_value)
    }
};

// Sets IOHandle to unbuffered mode.
// For detials, see Linux manual page for [setbuf()](https://man7.org/linux/man-pages/man3/setbuf.3.html).
//
// NOTE: When a fix program is invoked by `run_with_stream()`,
//       then the stdout and stderr becomes not a TTY but a file stream.
//       So the stdout becomes block-buffered. The stderr also seems to be block-buffered.
set_unbuffered_mode: [m: MonadIO] IOHandle -> m ();
set_unbuffered_mode = |handle| lift_io $ do {
    pure();;
    let file_ptr = *handle.get_file_ptr;
    FFI_CALL_IO[() setbuf(Ptr, Ptr), file_ptr, nullptr]
};

