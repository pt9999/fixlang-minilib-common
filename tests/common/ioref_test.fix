module IORefTest;

import Minilib.Common.IORef;
import Minilib.Common.TimeEx;
import Minilib.Monad.IO;
import Minilib.Testing.UnitTest;

test_ioref_simple: TestCase;
test_ioref_simple = (
    make_test("test_ioref_simple") $ |_|
    let ioref = *IORef::make(42);
    let ioref2 = ioref;
    assert_equal("eq", 42, *ioref.get);;
    ioref.put(43);;
    assert_equal("eq", 43, *ioref.get);;
    assert_equal("eq", 43, *ioref2.get);;
    ioref.mod(add(1));;
    assert_equal("eq", 44, *ioref.get);;
    assert_equal("eq", 44, *ioref2.get);;
    pure()
);

test_ioref_get: TestCase;
test_ioref_get = (
    make_test("test_ioref_get") $ |_|
    let ioref = *IORef::make([1,2,3]);
    let arr = *ioref.get;
    // arr is not unique at this point, since ioref retains it too
    assert_equal("eq", [1, 2, 3], arr);;
    let arr = *ioref.get;
    // now ioref is destroyed, so arr is unique
    let arr = arr.assert_unique(|_| "not unique");
    assert_equal("eq", [1, 2, 3], arr);;
    pure()
);

test_ioref_set: TestCase;
test_ioref_set = (
    make_test("test_ioref_set") $ |_|
    let ioref = *IORef::make([1,2,3]);
    let arr = *ioref.get;
    // arr is not unique at this point, since ioref retains it too
    assert_equal("eq", [1, 2, 3], arr);;
    ioref.IORef::set([4,5,6]);;
    let arr = *ioref.get;
    // now ioref is destroyed, so arr is unique
    let arr = arr.assert_unique(|_| "not unique");
    assert_equal("eq", [4, 5, 6], arr);;
    pure()
);

test_ioref_mod: TestCase;
test_ioref_mod = (
    make_test("test_ioref_mod") $ |_|
    let ioref = *IORef::make([1,2,3]);
    ioref.mod(|arr|
        // arr is unique in the modifier function
        arr.assert_unique(|_| "not unique")
        .set(0, 0)
    );;
    assert_equal("eq", [0, 2, 3], *ioref.get);;
    pure()
);

test_ioref_act: TestCase;
test_ioref_act = (
    make_test("test_ioref_act") $ |_|
    let ioref = *IORef::make([1,2,3]);
    let str = *ioref.act(|arr|
        // arr is unique in the action function
        let str = arr.to_string;
        let arr = arr.assert_unique(|_| "not unique").set(0, 0);
        pure $ (str, arr));
    assert_equal("eq", [0, 2, 3], *ioref.get);;
    assert_equal("eq", "[1, 2, 3]", str);;
    pure()
);

test_ioref_unboxed: TestCase;
test_ioref_unboxed = (
    make_test("test_ioref_unboxed") $ |_|
    let ioref = *IORef::make(ok(42): Result ErrMsg I64);
    let ioref2 = ioref;
    assert_equal("eq", ok(42), *ioref.get);;
    ioref.IORef::set(err("err"));;
    assert_equal("eq", err("err"), *ioref.get);;
    assert_equal("eq", err("err"), *ioref2.get);;
    ioref.mod(mod_err(|e| e+"or"));;
    assert_equal("eq", err("error"), *ioref.get);;
    assert_equal("eq", err("error"), *ioref2.get);;
    pure()
);

test_ioref_boxed: TestCase;
test_ioref_boxed = (
    make_test("test_ioref_boxed") $ |_|
    let ioref = *IORef::make(["a"]);
    let ioref2 = ioref;
    assert_equal("eq", ["a"], *ioref.get);;
    ioref.IORef::set(["a","b","c"]);;
    assert_equal("eq", ["a","b","c"], *ioref.get);;
    assert_equal("eq", ["a","b","c"], *ioref2.get);;
    ioref.mod(push_back("d"));;
    assert_equal("eq", ["a","b","c","d"], *ioref.get);;
    assert_equal("eq", ["a","b","c","d"], *ioref2.get);;
    pure()
);

// An object with `IORef I64`, which is reset to zero on destruction
type Obj = unbox struct {
    dtor: Destructor (IORef I64),
};

namespace Obj {
    make: [m: MonadIO] IORef I64 -> m Obj;
    make = |ior_i64| pure $ Obj {
        dtor: *Destructor::make(ior_i64, |ior_i64|
            let i = *ior_i64.get;
            if i == 0 { pure $ ior_i64 };
            //eprintln("destructor is called: i=" + i.to_string);;
            ior_i64.IORef::set(0);;
            pure $ ior_i64
        ).lift_io
    };

    get: [m: MonadIO] Obj -> m I64;
    get = |obj| obj.@dtor.borrow_io(|ior_i64| ior_i64.get).lift_io;

    get_ior: [m: MonadIO] Obj -> m (IORef I64);
    get_ior = |obj| obj.@dtor.borrow_io(|ior_i64| pure $ ior_i64).lift_io;
}

test_ioref_dtor: TestCase;
test_ioref_dtor = (
    make_test("test_ioref_dtor") $ |_|
    let ior_obj = *(
        let ior_i64: IORef I64 = *IORef::make(42);
        let obj = *Obj::make(ior_i64);
        IORef::make(obj)
    );
    let obj2: Obj = *ior_obj.get;
    // now ior_obj is dead, but obj2 is alive
    assert_equal("eq", 42, *obj2.get);;
    let ior_i64: IORef I64 = *obj2.get_ior;
    // now obj2 is dead, but ior_i64 is alive
    assert_equal("eq", 0, *ior_i64.get)
);

// Copies `IORef` as an unbox struct
copy_ior: IORef a-> IOFail (IORef a);
copy_ior = |IORef{dtor:dtor}| pure $ IORef{dtor:dtor};   // dtor is a boxed object, so only the reference of dtor is copyed

// Checks the values of `obj.get` and `obj.get_ior.get`
check_ior_obj: I64 -> I64 -> IORef Obj -> IOFail ();
check_ior_obj = |expected_obj_get, expected_obj_get_ior_get, ior_obj| (
    let obj: Obj = *ior_obj.get;
    assert_equal("eq", expected_obj_get, *obj.get);;
    let ior_i64: IORef I64 = *obj.get_ior;
    assert_equal("eq", expected_obj_get_ior_get, *ior_i64.get)
);

// Checks that:
// - Copying `IORef Obj` as an unbox struct will not affect to the referenced object
// - `IORef Obj` and `Obj` are destructed when they are not referenced any more
test_ioref_dtor_multi: TestCase;
test_ioref_dtor_multi = (
    make_test("test_ioref_dtor_multi") $ |_|
    let ior_obj: IORef Obj = *(
        let ior_i64: IORef I64 = *IORef::make(42);
        let obj = *Obj::make(ior_i64);
        IORef::make(obj)
    );
    let ior_obj = *copy_ior(ior_obj);
    check_ior_obj(42, 42, ior_obj);;
    let ior_obj = *copy_ior(ior_obj);
    check_ior_obj(42, 42, ior_obj);;
    // `IORef Obj` and `Obj` are destructed when they are not referenced any more
    // (before checing the value of `IORef I64`)
    check_ior_obj(42, 0, ior_obj)
);

test_ioref_borrow_ptr_io_from_ptr_ref_unref: TestCase;
test_ioref_borrow_ptr_io_from_ptr_ref_unref = (
    make_test("test_ioref_borrow_ptr_io_from_ptr_ref_unref") $ |_|
    let ptr: Ptr = *do {
        let ior_obj: IORef Obj = *(
            let ior_i64: IORef I64 = *IORef::make(42);
            let obj = *Obj::make(ior_i64);
            IORef::make(obj)
        );
        ior_obj.borrow_ptr_io(|ptr|
            // borrows ioref_t*, increment refcount, then return it
            ior_obj.ref;;   // +1
            pure $ ptr
        )
    }.lift;

    // restore ior_obj from the pointer
    let ior_obj: IORef Obj = *IORef::from_ptr(ptr);
    ior_obj.unref;;     // -1

    let obj2: Obj = *ior_obj.get;
    assert_equal("eq", 42, *obj2.get)
);

test_ioref_perf: TestCase;
test_ioref_perf = (
    make_test("test_ioref_perf") $ |_|
    let n = 1000;
    let ans = *timeit_io("test_ioref_perf", do {
        pure();;
        let ior = *IORef::make(0);
        range(0, n).fold_m(
            (), |i, _|
            ior.mod(add(i))
        );;
        ior.get
    });
    assert_equal("eq", ans, n * (n-1) / 2)
);

main : IO ();
main = (
    [
        test_ioref_simple,
        test_ioref_get,
        test_ioref_set,
        test_ioref_mod,
        test_ioref_act,
        test_ioref_unboxed,
        test_ioref_boxed,
        test_ioref_dtor,
        test_ioref_dtor_multi,
        test_ioref_borrow_ptr_io_from_ptr_ref_unref,
        test_ioref_perf,
    ]
    .run_test_driver
);
