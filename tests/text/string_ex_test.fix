module StringExTest;

import Character;

import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

test__unsafe_to_string: TestCase;
test__unsafe_to_string = (
    make_test("test__unsafe_to_string") $ |_|
    let array = [ 'a', 'b', 'c' ];
    let expected = "abc";
    let actual = array._unsafe_to_string;
    assert_equal("eq", expected, actual)
);

test_to_lower: TestCase;
test_to_lower = (
    make_test("test_to_lower") $ |_|
    assert_equal("eq", "", "".to_lower);;
    assert_equal("eq", " !0aa", " !0Aa".to_lower);;
    // a fraky test since the result varies by locale
    //assert_equal("eq", " !0aaààππあア", " !0AaÀàΠπあア".to_lower);;
    pure()
);

test_to_upper: TestCase;
test_to_upper = (
    make_test("test_to_upper") $ |_|
    assert_equal("eq", "", "".to_lower);;
    assert_equal("eq", " !0AA", " !0Aa".to_upper);;
    // a fraky test since the result varies by locale
    //assert_equal("eq", " !0AAÀÀΠΠあア", " !0AaÀàΠπあア".to_upper);;
    pure()
);

test_byte_to_string: TestCase;
test_byte_to_string = (
    make_test("test_byte_to_string") $ |_|
    assert_equal("from U8 literal", "A", 0x41_U8.byte_to_string);;
    assert_equal("from char literal", "B", 'B'.byte_to_string);;
    assert_equal("from NUL", "", 0x00_U8.byte_to_string);;
    pure()
);

test_fill: TestCase;
test_fill = (
    make_table_test("test_fill",
        [
            (-1, 'A', ""),
            (0, 'A', ""),
            (3, 'A', "AAA"),
            (3, 0_U8, ""),
        ],
        |(size, c, expected)|
        let actual = StringEx::fill(size, c);
        assert_equal("eq", expected, actual)
    )
);

test_find_byte: TestCase;
test_find_byte = (
    make_table_test("test_find_byte",
        [
            ("", 'a', none()),
            ("a", 'a', some(0)),
            ("a", 'b', none()),
            ("abab", 'a', some(0)),
            ("abab", 'b', some(1)),
            ("abab", 'c', none()),
        ],
        |(str, byte, expected)|
        let actual = str.find_byte(byte);
        assert_equal("eq", expected, actual)
    )
);

test_find_last_byte: TestCase;
test_find_last_byte = (
    make_table_test("test_find_last_byte",
        [
            ("", 'a', none()),
            ("a", 'a', some(0)),
            ("a", 'b', none()),
            ("abab", 'a', some(2)),
            ("abab", 'b', some(3)),
            ("abab", 'c', none()),
        ],
        |(str, byte, expected)|
        let actual = str.find_last_byte(byte);
        assert_equal("eq", expected, actual)
    )
);

test_get_prefix: TestCase;
test_get_prefix = (
    make_table_test("test_get_prefix",
        [
            (-1, "ABCDE", ""),
            (0, "", ""),
            (3, "", ""),
            (0, "ABCDE", ""),
            (3, "ABCDE", "ABC"),
            (5, "ABCDE", "ABCDE"),
            (6, "ABCDE", "ABCDE"),
        ],
        |(size, str, expected)|
        let actual = str.get_prefix(size);
        assert_equal("eq", expected, actual)
    )
);

test_get_suffix: TestCase;
test_get_suffix = (
    make_table_test("test_get_suffix",
        [
            (-1, "ABCDE", ""),
            (0, "", ""),
            (3, "", ""),
            (0, "ABCDE", ""),
            (3, "ABCDE", "CDE"),
            (5, "ABCDE", "ABCDE"),
            (6, "ABCDE", "ABCDE"),
        ],
        |(size, str, expected)|
        let actual = str.get_suffix(size);
        assert_equal("eq", expected, actual)
    )
);

test_pad_left: TestCase;
test_pad_left = (
    make_table_test("test_pad_left",
        [
            (-1, '.', "", ""),
            (0, '.', "", ""),
            (3, '.', "", "..."),
            (0, '0', "123", "123"),
            (3, '0', "123", "123"),
            (5, '0', "123", "00123"),
        ],
        |(size, c, str, expected)|
        let actual = str.pad_left(size, c);
        assert_equal("eq", expected, actual)
    )
);

test_pad_right: TestCase;
test_pad_right = (
    make_table_test("test_pad_right",
        [
            (-1, '.', "", ""),
            (0, '.', "", ""),
            (3, '.', "", "..."),
            (0, ' ', "abc", "abc"),
            (3, ' ', "abc", "abc"),
            (6, ' ', "abc", "abc   "),
        ],
        |(size, c, str, expected)|
        let actual = str.pad_right(size, c);
        assert_equal("eq", expected, actual)
    )
);

test_replace_all: TestCase;
test_replace_all = (
    make_table_test("test_replace_all",
        [
            // if `str` is empty, return empty.
            ("", "abc", "xyz", ""),
            // if `from` is empty, return `str`.
            ("abc", "", "xyz", "abc"),
            // if `from` is not found, return `str`.
            ("abc", "uvw", "xyz", "abc"),
            // `from` can be entire `str`
            ("abc", "abc", "xyz", "xyz"),
            // `from` may be a single character
            ("a", "a", "b", "b"),
            // replacement is not recursive
            ("aaabca", "a", "aa", "aaaaaabcaa"),
            ("aaaa", "aa", "bc", "bcbc"),
            // `to` can be empty
            ("abcdabcd", "bc", "", "adad"),
            // `to` can be longer than `from`
            ("abcdabcd", "bc", "xyz", "axyzdaxyzd"),
        ],
        |(str, from, to, expected)|
        let actual = str.replace_all(from, to);
        assert_equal("eq", expected, actual)
    )
);

test_replace_suffix: TestCase;
test_replace_suffix = (
    make_table_test("test_replace_suffix",
        [
            // if `str` ends with `from`, replace `from` with `to`.
            ("test.txt", ".txt", ".log", ok("test.log")),
            // if `str` does not end with `from`, an error occurs.
            ("test.jpg", ".txt", ".log", err("suffix does not match: test.jpg")),
            // if `from` is empty, `to` is appended to `str`.
            ("test.txt", "", ".new", ok("test.txt.new")),
            // if `to` is empty, `from` is removed from `str`.
            ("test.txt", ".txt", "", ok("test")),
            // `from` can be entire `str`
            ("test.txt", "test.txt", "xyz", ok("xyz")),
        ],
        |(str, from, to, expected)|
        let actual = str.replace_suffix(from, to);
        assert_equal("eq", expected, actual)
    )
);

test_split_first: TestCase;
test_split_first = (
    make_table_test("test_split_first",
        [
            ("", "", ("", "")),
            ("", "a", ("", "")),
            ("a", "", ("", "a")),
            ("a", "a", ("", "")),
            ("abcde", "", ("", "abcde")),
            ("abcde", "xy", ("abcde", "")),
            ("abcde", "bc", ("a", "de")),
            ("abcde", "de", ("abc", "")),
            ("abcde", "ab", ("", "cde")),
            ("abcde", "abcde", ("", "")),
            ("aaa/bbb/ccc", "bb", ("aaa/", "b/ccc")),
        ],
        |(str, delim, expected)|
        let actual = str.split_first(delim);
        assert_equal("eq", expected, actual)
    )
);

test_split_ex: TestCase;
test_split_ex = (
    make_table_test("test_split_ex",
        [
            ("", "", [""]),
            ("", "a", [""]),
            ("a", "", ["a"]),
            ("a", "b", ["a"]),
            ("a", "a", ["", ""]),
            ("ababa", "a", ["", "b", "b", ""]),
            ("ababa", "b", ["a", "a", "a"]),
            ("ababa", "aba", ["", "ba"]),
            ("ababa", "ababa", ["", ""]),
            ("ababa", "abcba", ["ababa"]),
        ],
        |(str, delim, expected)|
        let actual = str.split_ex(delim).to_array;
        assert_equal("eq", expected, actual)
    )
);

test_split_by: TestCase;
test_split_by = (
    make_table_test("test_split_by",
        [
            ("", "is_space", []),
            ("a", "is_alpha", []),
            ("a", "is_space", ["a"]),
            ("aa  bb  12", "is_space", ["aa", "bb", "12"]),
            ("  aa bb  12 ", "is_space", ["aa", "bb", "12"]),
            ("  aa bb  12 ", "const_false", ["  aa bb  12 "]),
            ("  aa bb  12 ", "const_true", []),
        ],
        |(str, is_delim, expected)|
        let is_delim = (
            if is_delim == "is_space" { is_space }
            else if is_delim == "is_alpha" { is_alpha }
            else if is_delim == "const_false" { |c| false }
            else if is_delim == "const_true" { |c| true }
            else { undefined("invalid is_delim") }
        );
        let actual = str.split_by(is_delim).to_array;
        assert_equal("eq", expected, actual)
    )
);

test_substring: TestCase;
test_substring = (
    make_table_test("test_substring",
        [
            ("", 0, 0, ""),
            ("", -1, 1, ""),
            ("abc", 0, 3, "abc"),
            ("abc", 0, 0, ""),
            ("abc", 0, 1, "a"),
            ("abc", 1, 2, "b"),
            ("abc", 2, 1, ""),
            ("abc", 3, 3, ""),
            ("abc", -1, 1, "a"),
            ("abc", 2, 4, "c"),
            ("abc", 5, 6, ""),
        ],
        |(str, s, e, expected)|
        let actual = str.substring(s,e);
        assert_equal("eq", expected, actual)
    )
);

// `format()` has many overloads that cannot be resolved with type variables.
// So I simply used `assert_equal()`.
test_format: TestCase;
test_format = (
    make_test("test_format") $ |_|
    assert_equal("no args", ([]: Array String).format(""), "");;
    assert_equal("one arg", ["abc"].format("{}"), "abc");;
    assert_equal("two args",["abc", "def"].format("{}{}"), "abcdef");;
    assert_equal("too many args", ["abc", "def", "ghi"].format("{}{}"), "abcdef");;
    assert_equal("too few args", ["abc"].format("{}{}"), "abc{}");;
    assert_equal("tuple1", (2.1_F32,).format("num={}"), "num=2.100000");;
    assert_equal("tuple2", (2.1, "hello").format("num={} str={}"), "num=2.100000 str=hello");;
    assert_equal("tuple3", (some(1_U16), [2,3,4], ()).format("option={} array={} unit={}"), "option=some(1) array=[2, 3, 4] unit=()");;
    assert_equal("tuple4", ('A', ['B', 'C'], [[1, 2]], ('D', "E")).format("u8={} array_u8={} array_array_i64={} tuple2={}"),
                                    "u8=65 array_u8=[66, 67] array_array_i64=[[1, 2]] tuple2=(68, E)");;
    assert_equal("tuple5", (1, 2.2, none(): Option I64, []: Array I64, (4,)).format("i64={} f64={} option={} array={} tuple1={}"),
                                    "i64=1 f64=2.200000 option=none() array=[] tuple1=(4,)");;
    assert_equal("cannot inject placeholder", ["dummy={}", "abc"].format("{}={}"), "dummy={}=abc");;
    pure()
);

main: IO ();
main = (
    [
        test__unsafe_to_string,
        test_to_lower,
        test_to_upper,
        test_byte_to_string,
        test_fill,
        test_find_byte,
        test_find_last_byte,
        test_get_prefix,
        test_get_suffix,
        test_pad_left,
        test_pad_right,
        test_replace_all,
        test_replace_suffix,
        test_split_first,
        test_split_ex,
        test_split_by,
        test_substring,
        test_format,
    ]
    .run_test_driver
);

